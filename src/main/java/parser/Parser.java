package parser;

import java.util.List;

import lexer.Token;
import lexer.TokenType;

/**
 * Recursive Descent Parser for the Students' Programming Language (SPL).
 *
 * Implements the full Context-Free Grammar using a recursive descent approach.
 * Includes public test methods to validate individual grammar rules.
 */
public class Parser {
    private final List<Token> tokens;
    private int current = 0; // Index of the next token to be consumed

    /**
     * Initializes the parser with the list of tokens generated by the Lexer.
     * @param tokens The list of tokens, ending with an EOF token.
     */
    public Parser(List<Token> tokens) {
        this.tokens = tokens;
    }

    /**
     * Starts the parsing process by calling the top-level rule, SPL_PROG.
     */
    public void parse() throws ParserException {
        System.out.println("Starting SPL parsing...");
        parseSPL_PROG(); 
        System.out.println("SPL Parsing successful!");
    }

    // --- Core Token Management Helper Methods ---

    /**
     * Checks if the current token's type is one of the given types.
     * If it is, consumes the token and returns true. Otherwise, returns false.
     */
    private boolean match(TokenType... types) {
        for (TokenType type : types) {
            if (check(type)) {
                advance();
                return true;
            }
        }
        return false;
    }

    /**
     * Checks if the current token is the expected type. If so, consumes it.
     * If not, throws a ParserException with a descriptive error message.
     */
    private Token expect(TokenType type, String message) throws ParserException {
        if (check(type)) {
            return advance();
        }
        Token currentToken = peek();
        // Providing detailed error context is critical for debugging
        throw new ParserException(
            String.format("%s. Found '%s' (%s) at %d:%d", 
                message, currentToken.getLexeme(), currentToken.getType(), 
                currentToken.getLine(), currentToken.getColumn())
        );
    }

    /**
     * Consumes the current token and returns it, moving the parser to the next token.
     */
    private Token advance() {
        if (!isAtEnd()) {
            current++;
        }
        return previous();
    }

    /**
     * Returns true if we have consumed all tokens (i.e., we are looking at EOF).
     */
    private boolean isAtEnd() {
        return peek().getType() == TokenType.EOF;
    }

    /**
     * Returns the current token we are looking at (the one at index 'current').
     */
    private Token peek() {
        return tokens.get(current);
    }

    /**
     * Returns the token that was just consumed (the one at index 'current - 1').
     */
    private Token previous() {
        return tokens.get(current - 1);
    }

    /**
     * Only checks the type of the current token, returns true if it matches.
     */
    private boolean check(TokenType type) {
        if (isAtEnd()) return type == TokenType.EOF;
        return peek().getType() == type;
    }

    // =========================================================================
    // Grammar Rules Implementation
    // =========================================================================

    // VAR ::= user-defined-name, NAME ::= user-defined-name
    private Token parseNAME() throws ParserException {
        return expect(TokenType.IDENTIFIER, "Expected a user-defined name (IDENTIFIER).");
    }
    private Token parseVAR() throws ParserException {
        return parseNAME(); 
    }
    
    // UNOP ::= neg | not
    private Token parseUNOP() throws ParserException {
        if (match(TokenType.NEG, TokenType.NOT)) {
            return previous();
        }
        throw new ParserException("Expected unary operator 'neg' or 'not'.");
    }
    
    // BINOP ::= eq | > | or | and | plus | minus | mult | div
    private Token parseBINOP() throws ParserException {
        if (match(TokenType.EQ, TokenType.GT, TokenType.OR, TokenType.AND, 
                     TokenType.PLUS, TokenType.MINUS, TokenType.MULT, TokenType.DIV)) {
            return previous();
        }
        throw new ParserException("Expected binary operator.");
    }

    // ATOM ::= VAR | number
    private Token parseATOM() throws ParserException {
        if (check(TokenType.IDENTIFIER)) {
            return parseVAR(); 
        } else if (match(TokenType.NUMBER)) {
            return previous();
        }
        throw new ParserException("Expected an ATOM (variable name or number literal).");
    }
    
    // OUTPUT ::= ATOM | string
    private void parseOUTPUT() throws ParserException {
        if (match(TokenType.STRING)) {
            return;
        } else if (check(TokenType.IDENTIFIER) || check(TokenType.NUMBER)) {
            parseATOM();
            return;
        }
        throw new ParserException("Expected an OUTPUT (ATOM or string literal).");
    }

    // VARIABLES ::= VAR NAME ; VARIABLES | IDENTIFIER [ ; ]* | epsilon
    private void parseVARIABLES() throws ParserException {
        // First: accept zero or more 'var NAME ;' sequences (existing behaviour)
        while (match(TokenType.VAR)) {
            parseNAME(); // Variable name
            expect(TokenType.SEMICOLON, "Expected ';' after VAR declaration.");
        }

        // Second: also allow a simple list of bare IDENTIFIER names (e.g., glob { x y z })
        // Each name may optionally be followed by a semicolon. Stop when we hit a non-IDENTIFIER.
        while (check(TokenType.IDENTIFIER)) {
            parseNAME();
            // consume an optional semicolon between bare names
            if (check(TokenType.SEMICOLON)) {
                advance();
            }
        }
    }

    // MAXTHREE ::= VAR [VAR [VAR]] | epsilon (max 3 VARs)
    private void parseMAXTHREE() throws ParserException {
        int count = 0;
        // This rule is defined by the contents inside the 'local {}' block.
        while (check(TokenType.VAR) && count < 3) {
            match(TokenType.VAR);
            parseNAME();
            expect(TokenType.SEMICOLON, "Expected ';' after local VAR declaration.");
            count++;
        }
    }
    
    // INPUT ::= ATOM [ATOM [ATOM]] | epsilon (max 3 ATOMs)
    private void parseINPUT() throws ParserException {
        int count = 0;
        // The key fix: Arguments are only separated by spaces, not commas.
        while ((check(TokenType.IDENTIFIER) || check(TokenType.NUMBER)) && count < 3) {
            parseATOM(); 
            count++;
        }
        if ((check(TokenType.IDENTIFIER) || check(TokenType.NUMBER))) {
            throw new ParserException("INPUT rule violated: not more than three ATOM arguments allowed.");
        }
    }
    
    // TERM ::= ATOM | ( UNOP TERM ) | ( TERM BINOP TERM )
    private void parseTERM() throws ParserException {
        if (check(TokenType.IDENTIFIER) || check(TokenType.NUMBER)) {
            // TERM ::= ATOM
            parseATOM();
            return;
        }
        
        if (match(TokenType.LPAREN)) {
            // Check for UNOP
            if (check(TokenType.NEG) || check(TokenType.NOT)) {
                // TERM ::= ( UNOP TERM )
                parseUNOP();
                parseTERM();
            } else {
                // TERM ::= ( TERM BINOP TERM )
                parseTERM(); // First TERM
                parseBINOP();
                parseTERM(); // Second TERM
            }
            expect(TokenType.RPAREN, "Expected ')' to close term expression.");
            return;
        }
        
        throw new ParserException("Expected a TERM (ATOM or a parenthesized expression).");
    }

    // PARAM ::= NAME [NAME [NAME]] | epsilon (max 3)
    private void parsePARAM() throws ParserException {
        int count = 0;
        // The key fix: Parameters are only separated by spaces, not commas.
        while (check(TokenType.IDENTIFIER) && count < 3) {
            parseNAME();
            count++;
        }
         if (check(TokenType.IDENTIFIER)) {
            throw new ParserException("PARAM rule violated: not more than three parameters allowed.");
        }
    }
    
    // BODY ::= local { MAXTHREE } ALGO
    private void parseBODY() throws ParserException {
        expect(TokenType.LOCAL, "Expected 'local' keyword to start the BODY block.");
        expect(TokenType.LBRACE, "Expected '{' after 'local'.");
        parseMAXTHREE(); // Local variables (nullable, max 3)
        expect(TokenType.RBRACE, "Expected '}' to close the local variable block in BODY.");
        parseALGO();
    }
    
    // ASSIGN ::= VAR = NAME ( INPUT ) | VAR = TERM
    private void parseASSIGN() throws ParserException {
        parseVAR(); 
        expect(TokenType.ASSIGN, "Expected '=' for assignment.");

        // Multi-token lookahead: If the next token is IDENTIFIER AND the token after that is '(', it's a function call.
        if (check(TokenType.IDENTIFIER) && current + 1 < tokens.size() && tokens.get(current + 1).getType() == TokenType.LPAREN) {
            // ASSIGN ::= VAR = NAME ( INPUT )
            parseNAME();
            expect(TokenType.LPAREN, "Expected '(' for function call after function name.");
            parseINPUT();
            expect(TokenType.RPAREN, "Expected ')' to close function call arguments.");
        } else {
            // ASSIGN ::= VAR = TERM
            parseTERM();
        }
    }
    
    // LOOP ::= while TERM { ALGO } | do { ALGO } until TERM
    private void parseLOOP() throws ParserException {
        if (match(TokenType.WHILE)) {
            // while TERM { ALGO }
            parseTERM();
            expect(TokenType.LBRACE, "Expected '{' to start 'while' block.");
            parseALGO();
            expect(TokenType.RBRACE, "Expected '}' to end 'while' block.");
        } else if (match(TokenType.DO)) {
            // do { ALGO } until TERM
            expect(TokenType.LBRACE, "Expected '{' to start 'do' block.");
            parseALGO();
            expect(TokenType.RBRACE, "Expected '}' to end 'do' block.");
            expect(TokenType.UNTIL, "Expected 'until' keyword in 'do-until' loop.");
            parseTERM();
        } else {
            throw new ParserException("Expected 'while' or 'do' keyword to start a LOOP.");
        }
    }
    
    // BRANCH ::= if TERM { ALGO } [ else { ALGO } ]
    private void parseBRANCH() throws ParserException {
        expect(TokenType.IF, "Expected 'if' keyword to start a BRANCH.");
        parseTERM();
        expect(TokenType.LBRACE, "Expected '{' to start 'if' block.");
        parseALGO();
        expect(TokenType.RBRACE, "Expected '}' to end 'if' block.");
        
        // Optional ELSE block
        if (match(TokenType.ELSE)) {
            expect(TokenType.LBRACE, "Expected '{' to start 'else' block.");
            parseALGO();
            expect(TokenType.RBRACE, "Expected '}' to end 'else' block.");
        }
    }

   // INSTR ::= halt | print OUTPUT | NAME ( INPUT ) | ASSIGN | LOOP | BRANCH
    private void parseINSTR() throws ParserException {
        TokenType currentType = peek().getType();
        
        if (currentType == TokenType.IDENTIFIER) {
            // If the instruction starts with an IDENTIFIER, it MUST be an ASSIGN or PCALL. 
            // We use lookahead(1) to decide which one it is.
            TokenType nextType = lookahead(1).getType();
            if (nextType == TokenType.ASSIGN) {
                // ASSIGN: VAR = ...
                parseASSIGN();
                return;
            } else if (nextType == TokenType.LPAREN) {
                // PCALL: NAME ( ...
                parsePCALL();
                return;
            } else {
                throw new ParserException(String.format("Expected '=' or '(' after IDENTIFIER '%s' in instruction.", peek().getLexeme()));
            }
        }

        if (match(TokenType.HALT)) {
            // halt instruction
            return;
        } else if (match(TokenType.PRINT)) {
            // print OUTPUT instruction (OUTPUT can be ATOM or string)
            parseOUTPUT();
            return;
        } else if (currentType == TokenType.WHILE || currentType == TokenType.DO) {
            // LOOP instruction
            parseLOOP();
            return;
        } else if (currentType == TokenType.IF) {
            // BRANCH instruction
            parseBRANCH();
            return;
        }

        // Final catch-all for invalid instruction start
        throw new ParserException("Expected a valid Instruction (halt, print, procedure call, assignment, loop, or branch).");
    }

    private Token lookahead(int k) {
        if (current + k >= tokens.size()) {
            // Return an EOF token if we look past the end of the list
            return new Token(TokenType.EOF, "", 0, 0);
        }
        return tokens.get(current + k);
    }


    private void parsePCALL() throws ParserException {
        // NAME (Procedure/Function name)
        expect(TokenType.IDENTIFIER, "Expected a procedure or function name to start the call."); 
        
        // (
        expect(TokenType.LPAREN, "Expected '(' to start procedure arguments.");
        
        parseINPUT();
        
        // )
        expect(TokenType.RPAREN, "Expected ')' to close procedure arguments.");
    }



    // ALGO ::= INSTR | INSTR ; ALGO (non-nullable)
    private void parseALGO() throws ParserException {
        // 1. Must consume at least one instruction (ALGO is non-nullable)
        parseINSTR(); 

        // 2. After parsing an instruction, check what comes next
        while (true) {
            TokenType currentType = peek().getType();
            
            // Valid stopping points: '}' (end of block), 'return' keyword, or EOF
            if (currentType == TokenType.RBRACE || currentType == TokenType.RETURN || currentType == TokenType.EOF) {
                break;
            }
            
            // If there's a semicolon, check if another instruction follows
            if (check(TokenType.SEMICOLON)) {
                TokenType nextType = lookahead(1).getType();
                
                // Check if the next token is a valid start for an instruction
                if (nextType == TokenType.HALT || nextType == TokenType.PRINT || 
                    nextType == TokenType.WHILE || nextType == TokenType.DO || 
                    nextType == TokenType.IF || nextType == TokenType.IDENTIFIER) {
                    
                    expect(TokenType.SEMICOLON, "Expected ';' between instructions.");
                    parseINSTR();
                } else {
                    // Semicolon followed by non-instruction (like 'return') - stop here
                    break;
                }
            }  else {
                // No semicolon, but also not at a valid stopping point
                // Check if it's an instruction token (missing semicolon error)
                if (currentType == TokenType.HALT || currentType == TokenType.PRINT || 
                    currentType == TokenType.WHILE || currentType == TokenType.DO || 
                    currentType == TokenType.IF || currentType == TokenType.IDENTIFIER) {
                    throw new ParserException("Expected a valid Instruction (halt, print, procedure call, assignment, loop, or branch).");
                }
                // For any other unexpected token, let the parent function handle it
                // (e.g., 'else' without '}' in a branch, or other structural errors)
                break;
            }
        }
    }
    
    // PDEF ::= NAME ( PARAM ) { BODY }
    private void parsePDEF() throws ParserException {
        parseNAME(); // Procedure name
        expect(TokenType.LPAREN, "Expected '(' to start procedure parameters.");
        parsePARAM(); // Nullable
        expect(TokenType.RPAREN, "Expected ')' to end procedure parameters.");
        expect(TokenType.LBRACE, "Expected '{' to start procedure body.");
        parseBODY();
        expect(TokenType.RBRACE, "Expected '}' to end procedure body.");
    }

    // FDEF ::= NAME ( PARAM ) { BODY ; return ATOM }
    private void parseFDEF() throws ParserException {
        parseNAME(); // Function name
        expect(TokenType.LPAREN, "Expected '(' to start function parameters.");
        parsePARAM(); // Nullable
        expect(TokenType.RPAREN, "Expected ')' to end function parameters.");
        expect(TokenType.LBRACE, "Expected '{' to start function body.");
        
        parseBODY(); // Function body
        
        expect(TokenType.SEMICOLON, "Expected ';' before the 'return' statement.");
        expect(TokenType.RETURN, "Expected 'return' keyword in function body.");
        parseATOM();
        
        expect(TokenType.RBRACE, "Expected '}' to end function body.");
    }

    // PROCDEFS ::= PDEF PROCDEFS | epsilon
    private void parsePROCDEFS() throws ParserException {
        // PDEF starts with NAME (IDENTIFIER).
        while (check(TokenType.IDENTIFIER)) { 
            parsePDEF();
        }
    }

    // FUNCDEFS ::= FDEF FUNCDEFS | epsilon
    private void parseFUNCDEFS() throws ParserException {
        // FDEF starts with NAME (IDENTIFIER).
        while (check(TokenType.IDENTIFIER)) { 
            parseFDEF();
        }
    }

    // MAINPROG ::= var { VARIABLES } ALGO
    private void parseMAINPROG() throws ParserException {
        // The 'var' keyword before the local block is mandatory for MAINPROG
        expect(TokenType.VAR, "Expected 'var' keyword at the start of MAINPROG local variables.");
        expect(TokenType.LBRACE, "Expected '{' to open MAINPROG local variable block.");
        parseVARIABLES();
        expect(TokenType.RBRACE, "Expected '}' to close MAINPROG local variable block.");
        
        parseALGO();
    }

    // SPL_PROG ::= glob { VARIABLES } proc { PROCDEFS } func { FUNCDEFS } main { MAINPROG }
    private void parseSPL_PROG() throws ParserException {
        // 1. Globals
        expect(TokenType.GLOB, "Expected 'glob' keyword at program start.");
        expect(TokenType.LBRACE, "Expected '{' to start global variables block.");
        parseVARIABLES(); 
        expect(TokenType.RBRACE, "Expected '}' to end global variables block.");
        
        // 2. Procedures
        expect(TokenType.PROC, "Expected 'proc' keyword.");
        expect(TokenType.LBRACE, "Expected '{' to start procedure definitions block.");
        parsePROCDEFS(); 
        expect(TokenType.RBRACE, "Expected '}' to end procedure definitions block.");

        // 3. Functions
        expect(TokenType.FUNC, "Expected 'func' keyword.");
        expect(TokenType.LBRACE, "Expected '{' to start function definitions block.");
        parseFUNCDEFS(); 
        expect(TokenType.RBRACE, "Expected '}' to end function definitions block.");

        // 4. Main Program
        expect(TokenType.MAIN, "Expected 'main' keyword.");
        expect(TokenType.LBRACE, "Expected '{' to start main program block.");
        parseMAINPROG();
        expect(TokenType.RBRACE, "Expected '}' to end main program block.");

        // 5. End of File
        expect(TokenType.EOF, "Expected end of file (EOF) after program completion.");
    }

    // =========================================================================
    // PUBLIC TEST HARNESS METHODS (Used by Main.java)
    // =========================================================================

    public void testTERM() throws ParserException {
        parseTERM();
    }
    public void testASSIGN() throws ParserException {
        parseASSIGN();
    }
    public void testINPUT() throws ParserException {
        parseINPUT();
    }
    public void testLOOP() throws ParserException {
        parseLOOP();
    }
    public void testBRANCH() throws ParserException {
        parseBRANCH();
    }
    public void testALGO() throws ParserException {
        parseALGO();
    }
    public void testVARIABLES() throws ParserException {
        parseVARIABLES();
    }
    public void testPDEF() throws ParserException {
        parsePDEF();
    }
    public void testFDEF() throws ParserException {
        parseFDEF();
    }
    public void testMAINPROG() throws ParserException {
        parseMAINPROG();
    }
}
